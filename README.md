# AbstractStock
Данный пакет реализует концепцию абстрактного полиморфного класса с виртуальными методами и свойствами. <br>Полиморфиз - одна из концепций ООП.<br>
Виртуальные методы и свойства - т.е методы свойства которые определяются в момент выполнения.<br><br>
Данныц класс позволяет организовать код, опираясь только на общее поведение и возрощаемое значение вызываемых методов, и сигнатуры их параметров.

## Обзор
- <a href="#Установка">Установка</a>
- <a href="#Документация">Документация</a>
- <a href="#Использование">Использование</a>
- <a href="#Зачем">Зачем</a>
- <a href="#термины">Терминология</a>
- <a href="#Внутренние_перменные">Внутренние перменные</a>
- <a href="#API">API</a>

## <span id="Установка">Установка</span> 

Так пакет **abstractstock** является пакетом nodejs - то вам для установки понадобится менеджер пакетов, к примеру **npm**.<br>

Для установки пакета в качестве зависимомти другого пакета.

    npm install abstractstock

Что бы скачать git репозиторий пакета - вам так же понадобится   **git**. Выполните в терминалн следующий код 

    git clone https://github.com/dimkl-dev/AbstractStock.git && cd ./AbstractStock && npm install  


## <span id="Документация">Документация</span>
Подробная документация представлена ниже. Так же доступна документация в формате ***JSDoc***.

Для её просмотра можно использовать пакет [JSDocLive](https://www.npmjs.com/package/jsdoclive)

Для просмотра ***JSDoc*** документации у пакета установленного как зависимость -  в каталоге пакета наберите команду 

    cd ./node_modules/poolcall/ && jsdoclive ./

Если вы скачали git-репозиторий пакета наберите 

    jsdoclive ./ 

## <span id="Использование">Использование</span> 
<pre><code>
//Можно использовать любой объект. Это абстрактный пример.
let obj1 = {};
obj1.name = "Boris";
obj1.say = function(){console.log(`hello ${this.name}`)};
//----------------

let {AbstractStock} = require("abstractstock");
let obj2 = new AbstractStock();
obj2.initStock("obj1", obj1);

obj2.abstractProp("_name_", "name");
obj2.abstractProp("say", "say");
//----------------------
</code></pre>
## <span id="Зачем">Зачем</span>
Очень хороший вопрос зачем. JavaScript очень гибкий язык, но попробуйте взять ссылку на метод объекта и вызвать его в другом объекте
### example
<pre><code>
obj1 = {};
obj1.name = "Boris";
obj1.say = function(){console.log(`hello ${this.name}`)};
obj1.say()//выведет 'hello Boris'
</code></pre>
порпробуем взять у объекта obj1 метод say и вызвать его из объекта obj2

<code><pre>
obj2={};
obj2.say = obj1.say;
obj2.say(); // выведет 'hello undefined'
</code></pre>

Если мы хотим одолжить один метод и вызвать его в контексте другого - тогда всё хорошо. Но если нам не нужно изменять контекст выполнения функции? Тогда пример выше примет следующий вид.

<code><pre>
obj2={};
obj2.speak = ()=>{obj1.say;};
obj2.speak(); // выведет 'hello boris'
</code></pre>

Этот метод тоже можно использовать. Он работает пока работаем с объектами(в JavaScript функции тоже объекты)
Но этот приём не сработает если мы захоти с эмитировать взятие адреса у свойства имющий значение примитивного типа(строка или числа). Это можно с эмитировать при помощи свойств аксесоров(get и set свойства).

<pre><code>
obj2 = {
    say: ()=>{obj1.say()},
    get _name_(){return obj1.name},
    set _name_(pval){obj1.name = pval}
    /* если потребно определять акссесоры на
    существующем методе - то потребно использовать 
    Object.defineProperty*/
}


console.log(obj2.name); // выведет Boris
obj1.name = 'Ivan';
obj1.say();// выведет Ivan
obj2.say();// выведет Ivan

obj2._name_ = 'Peter';
obj1.say();// выведет Peter
obj2.say();// выведет Peter


</code></pre>

Как видитие, имитировать указатели и ссылки в Javascript можно. Но использую только встроенные возможности языка - это громоздко, и потребно учитывать на какие типы данных потребно ссылка

### Реализация ссылок при помощи AbstacktStock
Для на гляднасти я прпроведу ниже полный код реализации ссылок как на нативном JavaScript, так и использованием пакета AbstractStock.
#### Нативный JavaScript
<pre><code>
obj1 = {};
obj1.name = "Boris";
obj1.say = function(){console.log(`hello ${this.name}`)};

obj2 = {
say: ()=>{obj1.say()},
get _name_(){return obj1.name},
set _name_(pval){obj1.name = pval}
}
</code></pre>

#### с использованием AbstractStock
<pre><code>
let obj1 = {};
obj1.name = "Boris";
obj1.say = function(){console.log(`hello ${this.name}`)};

//---блок инициализации
let {AbstractStock} = require("abstractstock");
let obj2 = new AbstractStock();
obj2.initStock("obj1", obj1);

//----Определение ссылок
obj2.abstractProp("_name_", "name");
obj2.abstractProp("say", "say");
//----------------------
</code></pre>

Как можно видеть из примеров выше - при использование AbstractStock, потребно определить блок инициализации, но определение самих ссыллок - проще и нагляднее. На демонстрационном примере разница не велика, но с ростом числа ссылок - код определения ссыллок уменьшается до половины. И становится гораздо наглядней.

Всех кого заинтересовал данный подход - прошу проследовать дальше.

## <p id="термины">Терминология</p>
Для реализация задумки был введён ряд понятий:

 -  **<a name="Абстрактный-накопитель">Абстрактный накопитель</a>** - экземпляр AbstractStock. До вызова функции [initStock](#initStock) абстрактный накопитель является не инициализированным и содержит лишь базовые методы. После вызова [initStock](#initStock) становится возможно создовать [абстрактные свойства](#Абстрактное-свойство) при помощи метода [abstractProp](#abstractProp)

 -  **<a name="Накопитель">Накопитель</a>** - [внешний объект](#Внешний-объект) 
 асоциированный с [абстрактным накопителем](#Абстрактный-накопитель). Ссылка на который хранится во 
 внутренний переменной [AS_stock](#AS_stock).
 Все [абстрактные свойства](#Абстрактное-свойство) разрешаются в контексте [накопителя](#Накопитель).
 У [абстрактного накопителя](#Абстрактный-накопитель) может быть только
 один [накопитель](#Накопитель) который можно получит через переменную создоваемую в 
 результате вызова функции [initStock](#initstock). Если в эту переменную происходит 
 запись значения - то происходит повторная привязка [внешнего объекта](#Внешний-объект), 
 при этом переменная созданая при вызове функции [initStock](#initstock) сохраняется прежней.
 Приэтом также изменяется контекст резрешения [абстрактных свойств](#Абстрактное-свойство).
 Если же в новом контексте какое либо [абстрактное свойство](#Абстрактное-свойство) 
 невозможно разрешить - то генерируется ошибка которая дополнена следующими свойствами:
    - oldStock - прежний [накопитель](#Накопитель)
    - newStock - новый [накопитель](#Накопитель)
    - stockValidRes - объект валидации [абстрактных свойств](#Абстрактное-свойство) (см. функцию [validStock](#validStock)) 


 -  **<a name="Внешний-объект">Внешний объект</a>** - любой объект не осоцеированный с [абстрактным накопителем](#Абстрактный-накопитель)

 -  **<a name="Абстрактное-свойство">Абстрактное свойство</a>** - метод или свойство
  [абстрактного накопителя](#Абстрактный-накопитель) созданное при помощи метода 
  [abstractProp](#abstractProp). [Абстрактное-свойство](#Абстрактное-свойство) 
  связано со свойством или методом [накопителя](#Накопитель). Эта связь определена
  во внутренней переменной [ASlist](#ASlist). Обращатся с 
  [абстрактным-свойством](#Абстрактное-свойство) возможно двумя способами:
    - **как с методом** - если связано с методом(т.е вункцией)
    - **как с свойством** - если связано со свойством(имеет объектный или примитивный тип данных)

 -  **<a name="Свойство-объекта">Свойство объекта</a>** - свойство или метод любого объекта



Термины не упомянутые в списке выше расматриваются в обще принятом смысле

## <span id="Внутренние_перменные">Внутренние переменные</span>
Здесь описаны перменные на которых держится работа класса. Прямого досту к ним нет, но можно получить ккопию их значений или ссылку на них. Этот раздел введён в описани, так как приего наличии легче объяснить работу некоторых функций и некоторые термины

### <a id="AS_stock">AS_stock</a>
Хранит ссылку на [внешний объект](#Внешний-объект). Является частью [накопителя](#Накопитель) 
который инициализируется функцией [initStock](#initstock). Именно в контексте этой переменной и разрешаются 
все [Абстрактные-свойства](#Абстрактное-свойство).  

### <a id="ASlist">ASlist</a>
Внутренняя перменная экземпляра объекта AbstractStock. Является картой сопастовление [абстрактных свойств](#Абстрактное-свойство). Перменная имеет тип объкта, значение свойств которой задаются внутри функции  [abstractProp](#abstractProp).

Сама переменная имеет следуюй вид 

<pre><code>
 {
     ....
     <b>abstractProp</b>: <b>stockProp</b>,
     ....
 }
</code></pre>

где: <br>
- abstractProp(string) - имя [абстрактного свойства](#Абстрактное-свойство)(параметр *abstractname*) 
- stockProp(string) - имя свойства у [внешнего объекта](#Внешний-объект)(параметр *stockname*)

Другими словами переменная является объектом, свойствами которого являются имена 
[абстрактных свойств](#Абстрактное-свойство), а значениями имена свойств или методов
 [накопителя](#Накопитель)




## <span id="API">API</span>

### <a name="initStock">initStock</a>
Инициализирует [Накопитель](#Накопитель).


#### парметры
| name| type | Description |
|---  |----  | --- |
| pname  | String  | имя [накопителя](#Накопитель) |
| pstock |Object   | [накопитель](#Накопитель)|

К одному экземпляру AbstractStock может быть привязан
только один [внешний объект](#Внешний-объект), а повторный вызов метода [initStock](#initStock) 
преведёт к следующим действиям:
 - переопределяет [накопитель](#Накопитель) (параметр pname)
 - для доступа к [накопителю](#Накопитель) создаёт новоё свойство у экземпляра класса AbstractStock
 - изменит контекст выполнение всех [абстрактных свойств](#Абстрактное-свойство) 
определённых  ранее. 
- Привязка свойства для доступа к [накопителю](#Накопитель), определённое ранее, 
также будет изменена(будет возврощать объект указанный в параметре pstock) 

Пример кода смотри [ниже](#пример_asap)


### <a name="abstractProp">abstractProp(abstractname, stockname)</a>

Определяет или переопределяет уже существующее [абстрактное свойство](#Абстрактное-свойство) 

#### парметры
| name| type | Description |
|---  |----  | --- |
| abstractname  | String  | имя [абстрактного свойства](#Абстрактное-свойство) |
| stockname |  string   | имя [свойства](#Свойство-объекта) в [накопителе](#Накопитель)|

Имя [абстрактного свойства](#Абстрактное-свойство) задоное в параметре abstractname
становится доступным как свойство экземпляра класс AbstractStock

#### <a id="пример_asap">пример</a>

```
    let arr = new Array(5,7,8)// это внешний объект(массив)
    let as = new AbstractStock // экземпляр класса AbstractStock

    //свяжем экземпляр класса AbstractStock с внешним объектом arr

    let pname = "as_array"; // свойствоо с этим именем и будет накопителем
    let pstock = arr;  // ссылка на внешний объект.
    as.initStock(pname, pstock);
    //arr теперь доступен также под именем as.as_array , или as[pname]
    console.log(arr === as[pname]);//true
    console.log(arr === as.as_array);//true

    // опрделелим as.in псевдонимом для метода arr.push
    let abstractname = "in";
    let stockname = "push";

    as.abstractProp(abstractname, stockname);

    //Обращаемся к определённому свойству
    as[abstractname](11); // as.in(11) - будет тотже результат

    console.log(arr);
    //[ 5,7,8,11 ]

    console.log(as[pname]); //или console.lof(as.as_array)
    //[ 5,7,8,11 ]

    // опрделелим as.count псевдонимом для свойства arr.length
    let abstractname2 = "count";
    let stockname2 = "length";
    as.abstractProp(abstractname, stockname);

    console.log(as.count) // или as[abstractname2]
    //3
```
При переопределение [абстрактного свойства](#Абстрактное-свойство)  в консоль 
выводится предупреждение в которое добавлены следующие свойства:
- **oldval** - пряжнее имя [свойства](#Свойство-объекта)  в [накопителе](#Накопитель)
- **newVal** - новое имя [свойства](#Свойство-объекта) в [накопителе](#Накопитель)
- **status** - принимает значение true или false в зависимости от того, есть ли
     новое имя [свойства](#Свойство-объекта) в [накопителе](#Накопитель)
- **CALLSTACK** - стэк вызова на моментнт определения [абстрактного свойства](#Абстрактное-свойство)

Если при определение нового [абстрактное свойство](#Абстрактное-свойство),  
 в [накопителе](#Накопитель) не найдено [свойство](#Свойство-объекта) с именем
 указаным в пармететре stockname - в консоль будет выведено  предупреждение, в которое 
 добавлены следующие свойства:
- **stockname** - имя [свойства](#Свойство-объекта)  в [накопителе](#Накопитель)
- **status** - иммет значение false
- **CALLSTACK** - стэк вызова на моментнт определения [абстрактного свойства](#Абстрактное-свойство)

### <a name="getASlist">getASlist</a>
Метод возращает копию карты абстрактных свойств(копию значений переменной [ASlist](#ASlist)) 
### <a name="getStock">getStock</a>
Возврощает ссылку на внутреннию переменную [AS_stock](@AS_stock), 
тем самым давая прямой доступ к [накопителю](#Накопитель). Данная возможность является экспериментальной.
Её наличие и поведение могут быть изменены в следующих версиях. 
### <a name="validStock">AbstractStock.prototype.validStock</a>


#### парметры
| name| type | Description |
|---  |----  | --- |
| [pstock = this.getStock()]<BR> *optiona*  | String  | [Внешний объект](#Внешний-объект) для валидации с [абстрактным накопителем](#Абстрактный-накопитель).  По умолчанию, в качестве [Внешнего объекта](#Внешний-объект) используется [Накопитель](#Накопитель). Т.е проверяет сам себя.|


Проверят возможность разрешения [Абстрактных свойств](#Абстрактное-свойство) отнсительно [внешнего объекта](#Внешний-объект) 
передоваемого через параметр *pstock*. В исходном коде(в коментариях указоно что эта функция проводит валидацию абстрактного накопителя. 
Это объясняется тем - что используется значение по умолчанию, и функция применяется для проверки коректности [Абстрактных сворйст](#Абстрактное-свойство) )

Возврощает объект с резултатами провкерки  и имеет следующую структуру:

    {
        status,
        abstractProps{
            abstractProp{
                stockProp,
                statusProp
            }
        }
    }

где:
- **status** (*boolean*: true|false) - общий статус провекрки. *true* - всё хорошо, 
*false*  - одно или более из  [Абстрактных свойствj](#Абстрактное-свойство) не прошло проверки.

- **abstractProps** - предстовляет собой хеш таблицу, Ключами которой являются имена
[Абстрактных свойств](#Абстрактное-свойство)(*abstractProp*), а значением каждого из клчей является
объект содержащий следующие данные

    - **stockProp** - имя свойства в объекте переданным через параметр *pstock*
    - **statusProp** (*boolean*: true|false) - статус проверки [Абстрактных свойствj](#Абстрактное-свойство)<br>
    *true* - имя свойства, переданного через **stockProp** есть в параметре *pstock*
    *false* - свойство, переданное через **stockProp** в параметре *pstock* не найдено.

